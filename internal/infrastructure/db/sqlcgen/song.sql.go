// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: song.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const existsSong = `-- name: ExistsSong :one
SELECT EXISTS (
  SELECT 1 FROM songs WHERE id = $1
) AS exists
`

func (q *Queries) ExistsSong(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsSong, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getSongDetailsByID = `-- name: GetSongDetailsByID :many
SELECT
    s.id AS id,
    s.name,
    s.kana,

    l.id AS lyrics_artist_id,
    l.name AS lyrics_artist_name,
    l.kana AS lyrics_artist_kana,

    m.id AS music_artist_id,
    m.name AS music_artist_name,
    m.kana AS music_artist_kana,

    a.id AS arrangement_artist_id,
    a.name AS arrangement_artist_name,
    a.kana AS arrangement_artist_kana,

    s.thumbnail,
    s.original_video,
    s.release_time,
    s.deleted,

    vp.id AS vocal_pattern_id,
    vp.name AS vocal_pattern_name,

    vps.singer_id,
    si.name AS singer_name,
    vps.position AS singer_order,

    su.unit_id,
    u.name AS unit_name,

    smvt.music_video_type AS music_video_type_id

FROM songs s
LEFT JOIN artists l ON s.lyrics_id = l.id
LEFT JOIN artists m ON s.music_id = m.id
LEFT JOIN artists a ON s.arrangement_id = a.id
LEFT JOIN vocal_patterns vp ON vp.song_id = s.id
LEFT JOIN vocal_pattern_singers vps ON vps.vocal_pattern_id = vp.id
LEFT JOIN singers si ON vps.singer_id = si.id
LEFT JOIN song_units su ON su.song_id = s.id
LEFT JOIN units u ON su.unit_id = u.id
LEFT JOIN song_music_video_types smvt ON smvt.song_id = s.id
WHERE s.id = $1
`

type GetSongDetailsByIDRow struct {
	ID                    int32
	Name                  string
	Kana                  string
	LyricsArtistID        sql.NullInt32
	LyricsArtistName      sql.NullString
	LyricsArtistKana      sql.NullString
	MusicArtistID         sql.NullInt32
	MusicArtistName       sql.NullString
	MusicArtistKana       sql.NullString
	ArrangementArtistID   sql.NullInt32
	ArrangementArtistName sql.NullString
	ArrangementArtistKana sql.NullString
	Thumbnail             sql.NullString
	OriginalVideo         sql.NullString
	ReleaseTime           sql.NullTime
	Deleted               sql.NullBool
	VocalPatternID        sql.NullInt32
	VocalPatternName      sql.NullString
	SingerID              sql.NullInt32
	SingerName            sql.NullString
	SingerOrder           sql.NullInt32
	UnitID                sql.NullInt32
	UnitName              sql.NullString
	MusicVideoTypeID      sql.NullInt32
}

func (q *Queries) GetSongDetailsByID(ctx context.Context, id int32) ([]GetSongDetailsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getSongDetailsByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSongDetailsByIDRow
	for rows.Next() {
		var i GetSongDetailsByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Kana,
			&i.LyricsArtistID,
			&i.LyricsArtistName,
			&i.LyricsArtistKana,
			&i.MusicArtistID,
			&i.MusicArtistName,
			&i.MusicArtistKana,
			&i.ArrangementArtistID,
			&i.ArrangementArtistName,
			&i.ArrangementArtistKana,
			&i.Thumbnail,
			&i.OriginalVideo,
			&i.ReleaseTime,
			&i.Deleted,
			&i.VocalPatternID,
			&i.VocalPatternName,
			&i.SingerID,
			&i.SingerName,
			&i.SingerOrder,
			&i.UnitID,
			&i.UnitName,
			&i.MusicVideoTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSong = `-- name: InsertSong :one
INSERT INTO songs (name, kana, lyrics_id, music_id, arrangement_id, thumbnail, original_video, release_time, deleted)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, name, kana, lyrics_id, music_id, arrangement_id, thumbnail, original_video, release_time, deleted
`

type InsertSongParams struct {
	Name          string
	Kana          string
	LyricsID      sql.NullInt32
	MusicID       sql.NullInt32
	ArrangementID sql.NullInt32
	Thumbnail     sql.NullString
	OriginalVideo sql.NullString
	ReleaseTime   sql.NullTime
	Deleted       sql.NullBool
}

func (q *Queries) InsertSong(ctx context.Context, arg InsertSongParams) (Song, error) {
	row := q.db.QueryRowContext(ctx, insertSong,
		arg.Name,
		arg.Kana,
		arg.LyricsID,
		arg.MusicID,
		arg.ArrangementID,
		arg.Thumbnail,
		arg.OriginalVideo,
		arg.ReleaseTime,
		arg.Deleted,
	)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Kana,
		&i.LyricsID,
		&i.MusicID,
		&i.ArrangementID,
		&i.Thumbnail,
		&i.OriginalVideo,
		&i.ReleaseTime,
		&i.Deleted,
	)
	return i, err
}

const listSongWithArtists = `-- name: ListSongWithArtists :many
SELECT
    s.id AS id,
    s.name,
    s.kana,

    l.id AS lyrics_artist_id,
    l.name AS lyrics_artist_name,
    l.kana AS lyrics_artist_kana,

    m.id AS music_artist_id,
    m.name AS music_artist_name,
    m.kana AS music_artist_kana,

    a.id AS arrangement_artist_id,
    a.name AS arrangement_artist_name,
    a.kana AS arrangement_artist_kana,

    s.thumbnail,
    s.original_video,
    s.release_time,
    s.deleted,

    vp.id AS vocal_pattern_id,
    vp.name AS vocal_pattern_name,

    vps.singer_id,
    si.name AS singer_name,
    vps.position AS singer_order,

    su.unit_id,
    u.name AS unit_name,

    smvt.music_video_type AS music_video_type_id

FROM songs s
LEFT JOIN artists l ON s.lyrics_id = l.id
LEFT JOIN artists m ON s.music_id = m.id
LEFT JOIN artists a ON s.arrangement_id = a.id
LEFT JOIN vocal_patterns vp ON vp.song_id = s.id
LEFT JOIN vocal_pattern_singers vps ON vps.vocal_pattern_id = vp.id
LEFT JOIN singers si ON vps.singer_id = si.id
LEFT JOIN song_units su ON su.song_id = s.id
LEFT JOIN units u ON su.unit_id = u.id
LEFT JOIN song_music_video_types smvt ON smvt.song_id = s.id
ORDER BY s.id
`

type ListSongWithArtistsRow struct {
	ID                    int32
	Name                  string
	Kana                  string
	LyricsArtistID        sql.NullInt32
	LyricsArtistName      sql.NullString
	LyricsArtistKana      sql.NullString
	MusicArtistID         sql.NullInt32
	MusicArtistName       sql.NullString
	MusicArtistKana       sql.NullString
	ArrangementArtistID   sql.NullInt32
	ArrangementArtistName sql.NullString
	ArrangementArtistKana sql.NullString
	Thumbnail             sql.NullString
	OriginalVideo         sql.NullString
	ReleaseTime           sql.NullTime
	Deleted               sql.NullBool
	VocalPatternID        sql.NullInt32
	VocalPatternName      sql.NullString
	SingerID              sql.NullInt32
	SingerName            sql.NullString
	SingerOrder           sql.NullInt32
	UnitID                sql.NullInt32
	UnitName              sql.NullString
	MusicVideoTypeID      sql.NullInt32
}

func (q *Queries) ListSongWithArtists(ctx context.Context) ([]ListSongWithArtistsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSongWithArtists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSongWithArtistsRow
	for rows.Next() {
		var i ListSongWithArtistsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Kana,
			&i.LyricsArtistID,
			&i.LyricsArtistName,
			&i.LyricsArtistKana,
			&i.MusicArtistID,
			&i.MusicArtistName,
			&i.MusicArtistKana,
			&i.ArrangementArtistID,
			&i.ArrangementArtistName,
			&i.ArrangementArtistKana,
			&i.Thumbnail,
			&i.OriginalVideo,
			&i.ReleaseTime,
			&i.Deleted,
			&i.VocalPatternID,
			&i.VocalPatternName,
			&i.SingerID,
			&i.SingerName,
			&i.SingerOrder,
			&i.UnitID,
			&i.UnitName,
			&i.MusicVideoTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
