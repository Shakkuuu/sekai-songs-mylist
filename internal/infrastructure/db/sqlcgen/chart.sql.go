// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: chart.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const existsChart = `-- name: ExistsChart :one
SELECT EXISTS (
  SELECT 1 FROM charts WHERE id = $1
) AS exists
`

func (q *Queries) ExistsChart(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsChart, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getChartWithSongWithArtistsByID = `-- name: GetChartWithSongWithArtistsByID :many
SELECT
    c.id AS id,

    s.id AS song_id,
    s.name AS song_name,
    s.kana AS song_kana,

    la.id AS lyrics_artist_id,
    la.name AS lyrics_artist_name,
    la.kana AS lyrics_artist_kana,

    ma.id AS music_artist_id,
    ma.name AS music_artist_name,
    ma.kana AS music_artist_kana,

    aa.id AS arrangement_artist_id,
    aa.name AS arrangement_artist_name,
    aa.kana AS arrangement_artist_kana,

    s.thumbnail,
    s.original_video,
    s.release_time,
    s.deleted,

    vp.id AS vocal_pattern_id,
    vp.name AS vocal_pattern_name,

    vps.singer_id,
    si.name AS singer_name,
    vps.position AS singer_order,

    su.unit_id,
    u.name AS unit_name,

    smvt.music_video_type AS music_video_type_id,

    c.difficulty_type,
    c.level,
    c.chart_view_link

FROM charts c
LEFT JOIN songs s ON c.song_id = s.id
LEFT JOIN artists la ON s.lyrics_id = la.id
LEFT JOIN artists ma ON s.music_id = ma.id
LEFT JOIN artists aa ON s.arrangement_id = aa.id
LEFT JOIN vocal_patterns vp ON vp.song_id = s.id
LEFT JOIN vocal_pattern_singers vps ON vps.vocal_pattern_id = vp.id
LEFT JOIN singers si ON vps.singer_id = si.id
LEFT JOIN song_units su ON su.song_id = s.id
LEFT JOIN units u ON su.unit_id = u.id
LEFT JOIN song_music_video_types smvt ON smvt.song_id = s.id
WHERE c.id = $1
`

type GetChartWithSongWithArtistsByIDRow struct {
	ID                    int32
	SongID                sql.NullInt32
	SongName              sql.NullString
	SongKana              sql.NullString
	LyricsArtistID        sql.NullInt32
	LyricsArtistName      sql.NullString
	LyricsArtistKana      sql.NullString
	MusicArtistID         sql.NullInt32
	MusicArtistName       sql.NullString
	MusicArtistKana       sql.NullString
	ArrangementArtistID   sql.NullInt32
	ArrangementArtistName sql.NullString
	ArrangementArtistKana sql.NullString
	Thumbnail             sql.NullString
	OriginalVideo         sql.NullString
	ReleaseTime           sql.NullTime
	Deleted               sql.NullBool
	VocalPatternID        sql.NullInt32
	VocalPatternName      sql.NullString
	SingerID              sql.NullInt32
	SingerName            sql.NullString
	SingerOrder           sql.NullInt32
	UnitID                sql.NullInt32
	UnitName              sql.NullString
	MusicVideoTypeID      sql.NullInt32
	DifficultyType        sql.NullInt32
	Level                 sql.NullInt32
	ChartViewLink         sql.NullString
}

func (q *Queries) GetChartWithSongWithArtistsByID(ctx context.Context, id int32) ([]GetChartWithSongWithArtistsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getChartWithSongWithArtistsByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChartWithSongWithArtistsByIDRow
	for rows.Next() {
		var i GetChartWithSongWithArtistsByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.SongID,
			&i.SongName,
			&i.SongKana,
			&i.LyricsArtistID,
			&i.LyricsArtistName,
			&i.LyricsArtistKana,
			&i.MusicArtistID,
			&i.MusicArtistName,
			&i.MusicArtistKana,
			&i.ArrangementArtistID,
			&i.ArrangementArtistName,
			&i.ArrangementArtistKana,
			&i.Thumbnail,
			&i.OriginalVideo,
			&i.ReleaseTime,
			&i.Deleted,
			&i.VocalPatternID,
			&i.VocalPatternName,
			&i.SingerID,
			&i.SingerName,
			&i.SingerOrder,
			&i.UnitID,
			&i.UnitName,
			&i.MusicVideoTypeID,
			&i.DifficultyType,
			&i.Level,
			&i.ChartViewLink,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertChart = `-- name: InsertChart :one
INSERT INTO charts (song_id, difficulty_type, level, chart_view_link)
VALUES ($1, $2, $3, $4)
RETURNING id, song_id, difficulty_type, level, chart_view_link
`

type InsertChartParams struct {
	SongID         sql.NullInt32
	DifficultyType sql.NullInt32
	Level          sql.NullInt32
	ChartViewLink  sql.NullString
}

func (q *Queries) InsertChart(ctx context.Context, arg InsertChartParams) (Chart, error) {
	row := q.db.QueryRowContext(ctx, insertChart,
		arg.SongID,
		arg.DifficultyType,
		arg.Level,
		arg.ChartViewLink,
	)
	var i Chart
	err := row.Scan(
		&i.ID,
		&i.SongID,
		&i.DifficultyType,
		&i.Level,
		&i.ChartViewLink,
	)
	return i, err
}

const listChartWithSongWithArtists = `-- name: ListChartWithSongWithArtists :many
SELECT
    c.id AS id,

    s.id AS song_id,
    s.name AS song_name,
    s.kana AS song_kana,

    la.id AS lyrics_artist_id,
    la.name AS lyrics_artist_name,
    la.kana AS lyrics_artist_kana,

    ma.id AS music_artist_id,
    ma.name AS music_artist_name,
    ma.kana AS music_artist_kana,

    aa.id AS arrangement_artist_id,
    aa.name AS arrangement_artist_name,
    aa.kana AS arrangement_artist_kana,

    s.thumbnail,
    s.original_video,
    s.release_time,
    s.deleted,

    vp.id AS vocal_pattern_id,
    vp.name AS vocal_pattern_name,

    vps.singer_id,
    si.name AS singer_name,
    vps.position AS singer_order,

    su.unit_id,
    u.name AS unit_name,

    smvt.music_video_type AS music_video_type_id,

    c.difficulty_type,
    c.level,
    c.chart_view_link

FROM charts c
LEFT JOIN songs s ON c.song_id = s.id
LEFT JOIN artists la ON s.lyrics_id = la.id
LEFT JOIN artists ma ON s.music_id = ma.id
LEFT JOIN artists aa ON s.arrangement_id = aa.id
LEFT JOIN vocal_patterns vp ON vp.song_id = s.id
LEFT JOIN vocal_pattern_singers vps ON vps.vocal_pattern_id = vp.id
LEFT JOIN singers si ON vps.singer_id = si.id
LEFT JOIN song_units su ON su.song_id = s.id
LEFT JOIN units u ON su.unit_id = u.id
LEFT JOIN song_music_video_types smvt ON smvt.song_id = s.id
ORDER BY c.id
`

type ListChartWithSongWithArtistsRow struct {
	ID                    int32
	SongID                sql.NullInt32
	SongName              sql.NullString
	SongKana              sql.NullString
	LyricsArtistID        sql.NullInt32
	LyricsArtistName      sql.NullString
	LyricsArtistKana      sql.NullString
	MusicArtistID         sql.NullInt32
	MusicArtistName       sql.NullString
	MusicArtistKana       sql.NullString
	ArrangementArtistID   sql.NullInt32
	ArrangementArtistName sql.NullString
	ArrangementArtistKana sql.NullString
	Thumbnail             sql.NullString
	OriginalVideo         sql.NullString
	ReleaseTime           sql.NullTime
	Deleted               sql.NullBool
	VocalPatternID        sql.NullInt32
	VocalPatternName      sql.NullString
	SingerID              sql.NullInt32
	SingerName            sql.NullString
	SingerOrder           sql.NullInt32
	UnitID                sql.NullInt32
	UnitName              sql.NullString
	MusicVideoTypeID      sql.NullInt32
	DifficultyType        sql.NullInt32
	Level                 sql.NullInt32
	ChartViewLink         sql.NullString
}

func (q *Queries) ListChartWithSongWithArtists(ctx context.Context) ([]ListChartWithSongWithArtistsRow, error) {
	rows, err := q.db.QueryContext(ctx, listChartWithSongWithArtists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChartWithSongWithArtistsRow
	for rows.Next() {
		var i ListChartWithSongWithArtistsRow
		if err := rows.Scan(
			&i.ID,
			&i.SongID,
			&i.SongName,
			&i.SongKana,
			&i.LyricsArtistID,
			&i.LyricsArtistName,
			&i.LyricsArtistKana,
			&i.MusicArtistID,
			&i.MusicArtistName,
			&i.MusicArtistKana,
			&i.ArrangementArtistID,
			&i.ArrangementArtistName,
			&i.ArrangementArtistKana,
			&i.Thumbnail,
			&i.OriginalVideo,
			&i.ReleaseTime,
			&i.Deleted,
			&i.VocalPatternID,
			&i.VocalPatternName,
			&i.SingerID,
			&i.SingerName,
			&i.SingerOrder,
			&i.UnitID,
			&i.UnitName,
			&i.MusicVideoTypeID,
			&i.DifficultyType,
			&i.Level,
			&i.ChartViewLink,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
